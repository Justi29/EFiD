---
title: "Projekt 2, grupa 5, spółka Betacom"
author: "Karolina Szot, Justyna Wachowiak, Julia Pawluś"
date: "2024-10-11"
output:
  html_document:
    code_folding: hide
  pdf_document: default
---
test
```{r message=FALSE, warning=FALSE, include=FALSE}
library(rmarkdown)
library(tseries)
library(forecast)
library(lmtest)
library(FinTS)
library(rugarch)
```

## Opis badania
Dane ze stooq, nie bylo naszego numerku spolki, dlatego wzielysmy z ostatnich 20 spolek.

## Dane BETACOM od 1 września 2023 do 4 października 2024

```{r}
dane <- read.csv2("bcm_d.csv", sep = ",", dec = ".", header = T)
paged_table(dane)
```
### Wyznaczenie logarytmicznych cen i stóp zwrotu
```{r}
df <- data.frame(Data = as.Date(dane$Data), Zamkniecie = dane$Zamkniecie, Zamkniecie_log = NA, Stopa_zwrotu_log = NA)
```

```{r}
# Log ceny
for (i in 1:nrow(df)){
  df[i, 3] <- log(df[i,2])
}

# Stopy zwrotu logarytmiczne
for (i in 2:nrow(df)){
  df[i, 4] <- log(df[i, 2]/df[i-1, 2])
}

new_df <- df[-1,]

# Nowe dane
paged_table(new_df)
```

### Podział danych na treningowe i testowe
opis
```{r}
train <- new_df[-((nrow(new_df)-3):nrow(new_df)), ]
test <-  tail(new_df, 4)
```
procentowe/liczbowe przedstawienie


## 1. Test ADF - badanie stacjonarności szeregów
H0: szereg jest niestacjonarny
H1: szereg jest stacjonarny

```{r warning=FALSE}
adf.test(train$Zamkniecie_log) # niestacjonarny
#  p-value = 0.7739 > 0.05

adf.test(train$Stopa_zwrotu_log) # stacjonarny
# p-value = 0.01 < 0.05
```
Z testów wynika, że logarytmiczne ceny są niestacjonarne, ponieważ p-value=0.7739, w związku z czym nie ma podstaw do odrzucenia H0. Natomiast, dla logarytmicznych stóp zwrotu p-value=0.01, zatem odrzucamy hipotezę zerową, czyli szereg jest stacjonarny.

## 2. Wybór modelu ARMA/ARIMA
```{r}
model <- auto.arima(train$Stopa_zwrotu_log)
model
```
Najlepszy model dla logarytmicznych stóp zwrotu  - ARIMA(0,0,1)
Interpretacja ARMA(0,1):

### Badanie autokorelacji składników losowych
#### Wykres ACF
```{r}
# składnik losowy == reszty
reszty <- model$residuals

# autokorelacja
Acf(reszty, main="ACF - Stopy zwrotu log")
```
Opis

#### Test Ljung-Boxa
H0: Brak autokorelacji
H1: Występuje autokorelacja

```{r}
Box.test(reszty, lag = 1, type = "Ljung-Box")$p.value
# 0.8797915 > 0.05 brak autokorelacji
```
Opis


### Badanie istotności parametrów przy najwyższych opóźnieniach
```{r}
coeftest(model)
```
Opis (u nas 1 opoznienie)

### Badanie białego szumu
Aby reszty były białym szumem, muszą spełniać następujące warunki:

1. Wartość oczekiwana równa zero. E(x) = 0
2. Stała wariancja. var(x) = const
3. Brak autokorelacji. corr = 0

W naszym modelu:
Na wcześniej przedstawionym wykresie ACF, jasno widać, że mamy brak autokorelacji w resztach modelu.
```{r}
cat("Średnia reszt: ", mean(reszty), "\n")
```

Test t-studenta:
H0: Średnia reszt jest równa zero.
H1: Średnia reszt jest różna od zera.
```{r}
t.test(reszty, mu = 0) # p-value = 0.9615 -> H0: średnia reszt = 0
```
p-value jest większe niż poziom istotności (0.05), a zatem nie ma podstaw do odrzucenia hipotezy zerowej, co oznacza, że średnia reszt nie różni się istotnie od zera.

Badanie wariancji reszt:
```{r}
reszty_sq <- reszty^2
Box.test(reszty_sq, lag = 1, type = "Ljung-Box") # p-value = 0.1194 -> brak autokorelacji
# Test Arch na heteroskedastyczność
ArchTest(reszty, lags = 1) # p-value = 0.122 -> no ARCH effects
```
Z testu Ljung-Boxa p-value wynosi 0.1194, czyli jest większe niż przyjęty poziom istotności 0.05, stąd też nie ma podstaw do odrzucenia hipotezy zerowej o braku autokorelacji w kwadratach reszt.
W teście ARCH p-value = 0.122, co również wskazuje na brak podstaw do odrzucenia hipotezy zerowej o braku efektów ARCH. Oznacza to, że nie występuje heteroskedastyczność w resztach modelu, czyli wariancja jest stała.

Reszty w tym modelu można uznać za biały szum.


## 3. Prognozy logarytmicznych stóp zwrotu, logarytmów cen i cen aż do 4 notowań.

Wybrany model z pkt.2 - ARMA(0,1).
Wyznaczamy najlepszy model dla logarytmicznych cen:
```{r}
model_2 <- auto.arima(train$Zamkniecie_log)
model_2
```
Wybieramy model ARIMA(0,1,1).

```{r}
stopy_zwr_model <- arima(train$Stopa_zwrotu_log, order=c(0,0,1))
ceny_log_model <- arima(train$Zamkniecie_log, order=c(0,1,1))
```

Zakładamy rozkład normalny dla logarytmicznych stóp zwrotu, czyli logarytmiczne ceny mają warunkowy rozkład normalmny. Zatem ceny mają rozkład logarytmicznie normalny.

#### Predykcje logarytmicznych stóp zwrotu
```{r}
forecast_values <- forecast(stopy_zwr_model, h=4)
predict <- as.data.frame(forecast_values)
real_values <- tail(test$Stopa_zwrotu_log, 4)

comparison <- data.frame(
  Actual = real_values,
  Forecast = predict$`Point Forecast`,
  Lower95 = predict$`Lo 95`,
  Upper95 = predict$`Hi 95`
)

paged_table(comparison)
```

#### Predykcje logarytmicznych cen
```{r}
forecast_values <- forecast(ceny_log_model, h=4)
predict_2 <- as.data.frame(forecast_values)
real_values <- tail(test$Zamkniecie_log, 4)

comparison_2 <- data.frame(
  Actual = real_values,
  Forecast = predict_2$`Point Forecast`,
  Lower95 = predict_2$`Lo 95`,
  Upper95 = predict_2$`Hi 95`
)

paged_table(comparison_2)
```

#### Predykcja cen. Zestawienie wszystkich predykcji wraz z przedziałami ufności
```{r}
predictions <- data.frame(
  Zamkniecie_pred = NA,
  Lower_cena = NA,
  Upper_cena = NA,
  Zamkniecie_log_pred = predict_2$`Point Forecast`,
  Lower_log_cena = predict_2$`Lo 95`,
  Upper_log_cena = predict_2$`Hi 95`,
  Stopa_zwrotu_log_pred = predict$`Point Forecast`,
  Lower_st_zw = predict$`Lo 95`,
  Upper_st_zw = predict$`Hi 95`
)


# Predykcja cen
for (i in 1:4){
  mi <- predictions[i,"Zamkniecie_log_pred"]
  
  temp_df <- as.data.frame(c(train$Zamkniecie_log, predictions$Zamkniecie_log[1:i]))
  colnames(temp_df) <- c("Zamkniecie_log_combined")
  
  # Odchylenie standardowe
  sigma <- sd(temp_df$Zamkniecie_log_combined)
  sigma2 <- sigma^2
  
  # Prognozowana cena
  predictions[i,"Zamkniecie_pred"] <- exp(mi+sigma2/2)
  
  z_value <- qnorm(0.975)
  # Obliczanie przedziałów ufności dla cen
  temp_df_2 <- as.data.frame(c(train$Zamkniecie, predictions$Zamkniecie_pred[1:i]))
  colnames(temp_df_2) <- c("Zamkniecie_combined")

  s <- sd(temp_df_2$Zamkniecie_combined)
  s2 <-s^2
  
  predictions[i, "Lower_cena"] <- exp(mi - z_value * sigma + 0.5 * s2)
  predictions[i, "Upper_cena"] <- exp(mi + z_value * sigma + 0.5 * s2)
}

paged_table(predictions)
```

#### Porównanie rzeczywistych wartości z predykcjami
```{r}
result_df <- as.data.frame(cbind(test$Zamkniecie, predictions$Zamkniecie_pred, test$Zamkniecie_log, predictions$Zamkniecie_log, test$Stopa_zwrotu_log, predictions$Stopa_zwrotu_log_pred))

colnames(result_df) <- c("Zamkniecie","Zamkniecie_pred","Zamkniecie_log","Zamkniecie_log_pred","Stopa_zwrotu_log","Stopa_zwrotu_log_pred")

paged_table(result_df)
```


## 4. Monte Carlo
Na podstawie rozkładu reszt modelu dopasowanego w pkt.2. symulacyjnie (za pomocą metody Monte Carlo) wyznaczyć prognozy logarytmów cen i samych cen aż do 4 notowań. Na tej podstawie wyznaczyć także 95% przedziały ufności dla wartości logarytmów cen i samych cen. Uzyskane w ten sposób wyniki porównać z prognozami z punktu 3. 

```{r}
reszty_2 <- residuals(ceny_log_model)
mu <- 0
sigma <- sd(reszty_2)

n_symulacji <- 1000
n_prognoz <- 4

prognozy_log <- matrix(0, nrow = n_symulacji, ncol = n_prognoz)

ostatni_log <- tail(train$Zamkniecie_log, 1)


set.seed(123)
for (j in 1:n_symulacji) {
  prognozy_log[j, 1] <- ostatni_log + rnorm(1, mean = mu, sd = sigma)
  for (i in 2:n_prognoz) {
    prognozy_log[j, i] <- prognozy_log[j, i - 1] + rnorm(1, mean = mu, sd = sigma)
  }
}

prognozy_ceny <- exp(prognozy_log + (sigma^2 / 2))

log_forecast_mean <- apply(prognozy_log, 2, mean)
log_ci_lower <- apply(prognozy_log, 2, function(x) quantile(x, probs = 0.025))
log_ci_upper <- apply(prognozy_log, 2, function(x) quantile(x, probs = 0.975))

cena_forecast_mean <- apply(prognozy_ceny, 2, mean)
cena_ci_lower <- apply(prognozy_ceny, 2, function(x) quantile(x, probs = 0.025))
cena_ci_upper <- apply(prognozy_ceny, 2, function(x) quantile(x, probs = 0.975))

log_ceny_results <- data.frame(
  Horyzont_Prognozy = 1:n_prognoz,
  Srednia_Log_Ceny = log_forecast_mean,
  Dolny_Przedzial95_Log = log_ci_lower,
  Gorny_Przedzial95_Log = log_ci_upper
)

ceny_results <- data.frame(
  Horyzont_Prognozy = 1:n_prognoz,
  Srednia_Ceny = cena_forecast_mean,
  Dolny_Przedzial95_Cena = cena_ci_lower,
  Gorny_Przedzial95_Cena = cena_ci_upper
)
```

#### Prognozy logarytmów cen
```{r}
paged_table(log_ceny_results)
```

#### Prognozy cen
```{r}
paged_table(ceny_results)
```

Opis - porównanie z 3

## 5. Metody bootstrapowe
Na podstawie oszacowanych reszt, za pomocą metod bootstrapowych wyznaczyć prognozy logarytmów cen i samych cen aż do 4 sesji. Wyznaczyć także 95% przedziały ufności dla wartości logarytmów cen i samych cen. Uzyskane w ten sposób wyniki porównać z prognozami z punktu 3 i 4.

```{r}
set.seed(123)

n_bootstrap <- 1000
n_prognoz <- 4
reszty_2 <- residuals(ceny_log_model)

prognozy_log_bootstrap <- matrix(0, nrow = n_bootstrap, ncol = n_prognoz)

ostatni_log <- tail(train$Zamkniecie_log, 1)


for (j in 1:n_bootstrap) {
  prognozy_log_bootstrap[j, 1] <- ostatni_log + sample(reszty_2, 1, replace = TRUE)
  for (i in 2:n_prognoz) {
    prognozy_log_bootstrap[j, i] <- prognozy_log_bootstrap[j, i - 1] + sample(reszty_2, 1, replace = TRUE)
  }
}

sigma <- sd(reszty_2)
prognozy_ceny_bootstrap <- exp(prognozy_log_bootstrap  + (sigma^2 / 2))

log_forecast_mean_bootstrap <- apply(prognozy_log_bootstrap, 2, mean)
log_ci_lower_bootstrap <- apply(prognozy_log_bootstrap, 2, function(x) quantile(x, probs = 0.025))
log_ci_upper_bootstrap <- apply(prognozy_log_bootstrap, 2, function(x) quantile(x, probs = 0.975))

cena_forecast_mean_bootstrap <- apply(prognozy_ceny_bootstrap, 2, mean)
cena_ci_lower_bootstrap <- apply(prognozy_ceny_bootstrap, 2, function(x) quantile(x, probs = 0.025))
cena_ci_upper_bootstrap <- apply(prognozy_ceny_bootstrap, 2, function(x) quantile(x, probs = 0.975))

log_ceny_bootstrap_results <- data.frame(
  Horyzont_Prognozy = 1:n_prognoz,
  Srednia_Log_Ceny = log_forecast_mean_bootstrap,
  Dolny_Przedzial95_Log = log_ci_lower_bootstrap,
  Gorny_Przedzial95_Log = log_ci_upper_bootstrap
)

ceny_bootstrap_results <- data.frame(
  Horyzont_Prognozy = 1:n_prognoz,
  Srednia_Ceny = cena_forecast_mean_bootstrap,
  Dolny_Przedzial95_Cena = cena_ci_lower_bootstrap,
  Gorny_Przedzial95_Cena = cena_ci_upper_bootstrap
)
```

#### Prognozy logarytmów cen
```{r}
paged_table(log_ceny_bootstrap_results)
```

#### Prognozy cen
```{r}
paged_table(ceny_bootstrap_results)
```

## 6. Model ARMA-GARCH
Badanie z punktów 3-5 powtórzyć przy założeniu występowania efektu ARCH, tzn. dla odpowiedniego modelu ARMA-GARCH. Przeprowadzić też test występowania efektu ARCH.

#### Test ARCH

1. Reszty z modelu logarytmicznych stóp zwrotu

```{r}
reszty_st_zw <- residuals(stopy_zwr_model)
ArchTest(reszty_st_zw, lags = 1)
```

2. Reszty z modelu logarytmicznych cen

```{r}
reszty_log <- residuals(ceny_log_model)
ArchTest(reszty_log, lags = 1)
```
W obu przypadkach p-value są większe niż przyjęty poziom istotności 0.05, dlatego odrzucamy H0, a to oznacza, że dla obu występują efekty ARCH.

W kolejnych krokach tworzymy dwa modele ARMA-GARCH dla logarytmicznych stóp zwrotu oraz logarytmicznych cen. Wykorzystujemy do tego modele ARMA(0,1) i GARCH(1,1). Następnie na ich podstawie zgodnie z podpunktem 3 wyznaczamy predykcje oraz przedziały ufności dla logarytmicznych stóp zwrotu, logarytmicznych cen oraz cen.

#### Badanie z pkt. 3
```{r}
# Dla arima(0,0,1), garch(1,1)
spec <- ugarchspec(
  variance.model = list(model = "sGARCH", garchOrder = c(1, 1)),
  mean.model = list(armaOrder = c(0, 1), include.mean = TRUE),
  distribution.model = "norm"
)

fit <- ugarchfit(spec = spec, data = train$Stopa_zwrotu_log)
```

```{r}
# dla arima(0,1,1), garch(1,1)
spec2 <- ugarchspec(
  variance.model = list(model = "sGARCH", garchOrder = c(1, 1)),
  mean.model = list(armaOrder = c(0, 1), include.mean = TRUE, arfima = TRUE),
  distribution.model = "norm"
)

fit2 <- ugarchfit(spec = spec2, data = train$Zamkniecie_log)
```

1. Predykcje oraz wyznaczone przedziały ufności:

```{r}
# Prognoza logarytmicznych stóp zwrotu
prognoza_stop_zwr <- ugarchforecast(fit, n.ahead = 4)
prognozy_stop_zwr <- data.frame(Prognoza_Stopy_Zwrotu=prognoza_stop_zwr@forecast$seriesFor,Wariancja_Stopy_Zwrotu=prognoza_stop_zwr@forecast$sigmaFor)
colnames(prognozy_stop_zwr) <- c("Prognoza_Stopy_Zwrotu", "Wariancja_Stopy_Zwrotu")

# Prognoza logarytmicznych cen
prognoza_log_cena <- ugarchforecast(fit2, n.ahead = 4)
prognoza_log_cena <- data.frame(Prognoza_Log_Cena=prognoza_log_cena@forecast$seriesFor,Wariancja_Log=prognoza_log_cena@forecast$sigmaFor)
colnames(prognoza_log_cena) <- c("Prognoza_Log_Cena","Wariancja_Log")

predictions_pkt6 <- data.frame(
  Zamkniecie_pred = NA,
  Lower_cena = NA,
  Upper_cena = NA,
  Zamkniecie_log_pred = prognoza_log_cena$Prognoza_Log_Cena,
  Lower_log_cena = NA,
  Upper_log_cena = NA,
  Stopa_zwrotu_log_pred = prognozy_stop_zwr$Prognoza_Stopy_Zwrotu,
  Lower_st_zw = NA,
  Upper_st_zw = NA
)

for (i in 1:4){
  mu <- predictions_pkt6[i,"Zamkniecie_log_pred"]
  sigma2 <- prognoza_log_cena[i, "Wariancja_Log"]
  sigma <- sqrt(sigma2)
  
  # Prognozowana cena
  predictions_pkt6[i,"Zamkniecie_pred"] <- exp(mu+0.5*sigma2)
  
  z_value <- qnorm(0.975)
  # Obliczanie przedziałów ufności dla logarytmicznych cen
  predictions_pkt6[i, "Lower_log_cena"] <- mu - z_value * sqrt(sigma2)
  predictions_pkt6[i, "Upper_log_cena"] <- mu + z_value * sqrt(sigma2)
  
  # Obliczanie przedziałów ufności dla cen
  predictions_pkt6[i, "Lower_cena"] <- exp(mu - z_value * sigma + 0.5 * sigma2)
  predictions_pkt6[i, "Upper_cena"] <- exp(mu + z_value * sigma + 0.5 * sigma2)
  
  # Obliczanie przedziałów ufności dla logarytmicznych stóp zwrotu
  mu_2 <- predictions_pkt6[i,"Stopa_zwrotu_log_pred"]
  s2 <- prognozy_stop_zwr[i, "Wariancja_Stopy_Zwrotu"]
  
  predictions_pkt6[i, "Lower_st_zw"] <- mu_2 - z_value * sqrt(s2)
  predictions_pkt6[i, "Upper_st_zw"] <- mu_2 + z_value * sqrt(s2)
}

paged_table(predictions_pkt6)
```

2. Porównanie rzeczywistych wartości z predykcjami:

```{r}
# Porównanie rzeczywistych wartości z predykcjami
result_df_pkt6 <- as.data.frame(cbind(test$Zamkniecie, predictions_pkt6$Zamkniecie_pred, test$Zamkniecie_log, predictions_pkt6$Zamkniecie_log_pred, test$Stopa_zwrotu_log, predictions_pkt6$Stopa_zwrotu_log_pred))

colnames(result_df_pkt6) <- c("Zamkniecie","Zamkniecie_pred","Zamkniecie_log","Zamkniecie_log_pred","Stopa_zwrotu_log","Stopa_zwrotu_log_pred")

paged_table(result_df_pkt6)
```

Wartości w kolumnach 'Zamknięcie' i 'Zamknięcie_pred' (ceny zwykłe) są do siebie zbliżone. Jedynie predykcja T+2 różni się prawie o 0.2. Pozostałe predykcje nie przekraczają 0.1.
Podobnie, wartości w kolumnach 'Zamknięcie_log' i 'Zamknięcie_log_pred' (logarytmiczne ceny) są bardzo zbliżone, co wskazuje, że model dość dobrze odwzorowuje rzeczywiste wartości.
Z kolei wartości rzeczywiste ('Stopa_zwrotu_log') i prognozowane ('Stopa_zwrotu_log_pred') różnią się bardziej znacząco niż w poprzednich przypadkach. Model przewiduje jednakową wartość logarytmicznej stopy zwrotu w trzech ostatnich predykcjach, gdzie przewidywana wartość wynosi 0.0004695031. Widać również, że przewidywane wartości zmieniają się zarówno dodatnio, jak i ujemnie.


#### Badanie z pkt. 4 - Monte Carlo

```{r}
reszty_fit2 <- residuals(fit2)
mu <- 0
sigma <- sd(reszty_fit2)

n_symulacji <- 1000
n_prognoz <- 4

prognozy_log <- matrix(0, nrow = n_symulacji, ncol = n_prognoz)

ostatni_log <- tail(train$Zamkniecie_log, 1)


set.seed(123)
for (j in 1:n_symulacji) {
  prognozy_log[j, 1] <- ostatni_log + rnorm(1, mean = mu, sd = sigma)
  for (i in 2:n_prognoz) {
    prognozy_log[j, i] <- prognozy_log[j, i - 1] + rnorm(1, mean = mu, sd = sigma)
  }
}

prognozy_ceny <- exp(prognozy_log + (sigma^2 / 2))

log_forecast_mean <- apply(prognozy_log, 2, mean)
log_ci_lower <- apply(prognozy_log, 2, function(x) quantile(x, probs = 0.025))
log_ci_upper <- apply(prognozy_log, 2, function(x) quantile(x, probs = 0.975))

cena_forecast_mean <- apply(prognozy_ceny, 2, mean)
cena_ci_lower <- apply(prognozy_ceny, 2, function(x) quantile(x, probs = 0.025))
cena_ci_upper <- apply(prognozy_ceny, 2, function(x) quantile(x, probs = 0.975))

log_ceny_results <- data.frame(
  Horyzont_Prognozy = 1:n_prognoz,
  Srednia_Log_Ceny = log_forecast_mean,
  Dolny_Przedzial95_Log = log_ci_lower,
  Gorny_Przedzial95_Log = log_ci_upper
)

ceny_results <- data.frame(
  Horyzont_Prognozy = 1:n_prognoz,
  Srednia_Ceny = cena_forecast_mean,
  Dolny_Przedzial95_Cena = cena_ci_lower,
  Gorny_Przedzial95_Cena = cena_ci_upper
)
```

1. Prognozy logarytmów cen:

```{r}
paged_table(log_ceny_results)
```

2. Prognozy cen

```{r}
paged_table(ceny_results)
```


#### Badanie z pkt. 5 - metody bootstrapowe
```{r}
set.seed(123)

reszty_fit2 <- residuals(fit2)

prognozy_log_bootstrap <- matrix(0, nrow = n_bootstrap, ncol = n_prognoz)

ostatni_log <- tail(train$Zamkniecie_log, 1)


for (j in 1:n_bootstrap) {
  prognozy_log_bootstrap[j, 1] <- ostatni_log + sample(reszty_fit2, 1, replace = TRUE)
  for (i in 2:n_prognoz) {
    prognozy_log_bootstrap[j, i] <- prognozy_log_bootstrap[j, i - 1] + sample(reszty_fit2, 1, replace = TRUE)
  }
}

sigma <- sd(reszty_fit2)
prognozy_ceny_bootstrap <- exp(prognozy_log_bootstrap  + (sigma^2 / 2))

log_forecast_mean_bootstrap <- apply(prognozy_log_bootstrap, 2, mean)
log_ci_lower_bootstrap <- apply(prognozy_log_bootstrap, 2, function(x) quantile(x, probs = 0.025))
log_ci_upper_bootstrap <- apply(prognozy_log_bootstrap, 2, function(x) quantile(x, probs = 0.975))

cena_forecast_mean_bootstrap <- apply(prognozy_ceny_bootstrap, 2, mean)
cena_ci_lower_bootstrap <- apply(prognozy_ceny_bootstrap, 2, function(x) quantile(x, probs = 0.025))
cena_ci_upper_bootstrap <- apply(prognozy_ceny_bootstrap, 2, function(x) quantile(x, probs = 0.975))

log_ceny_bootstrap_results <- data.frame(
  Horyzont_Prognozy = 1:n_prognoz,
  Srednia_Log_Ceny = log_forecast_mean_bootstrap,
  Dolny_Przedzial95_Log = log_ci_lower_bootstrap,
  Gorny_Przedzial95_Log = log_ci_upper_bootstrap
)

ceny_bootstrap_results <- data.frame(
  Horyzont_Prognozy = 1:n_prognoz,
  Srednia_Ceny = cena_forecast_mean_bootstrap,
  Dolny_Przedzial95_Cena = cena_ci_lower_bootstrap,
  Gorny_Przedzial95_Cena = cena_ci_upper_bootstrap
)
```

1. Bootstrapowe prognozy logarytmów cen

```{r}
paged_table(log_ceny_bootstrap_results)
```

2. Bootstrapowe prognozy cen

```{r}
paged_table(ceny_bootstrap_results)
```

#### Porównanie wyników z poprzednimi prognozami logarytmicznych cen i cen

1. Porównanie logarytmicznych cen

```{r}
final_comparison_log_ceny <- as.data.frame(cbind(
  test$Zamkniecie_log, 
  predictions_pkt6$Zamkniecie_log_pred,
  log_ceny_results$Srednia_Log_Ceny,
  log_ceny_bootstrap_results$Srednia_Log_Ceny
  ))

colnames(final_comparison_log_ceny) <- c("Rzeczywiste_ceny_log","Ceny_log_pred_3","Ceny_log_pred_4","Ceny_log_pred_5")

paged_table(final_comparison_log_ceny)
```

Wartości prognozowane są bliskie rzeczywistym wartościom logarytmicznym cen, jednakże każda z prognoz (3, 4, 5) wykazuje pewne odchylenia w stosunku do rzeczywistych cen. 'Ceny_log_pred_3' wydaje się najbliższa rzeczywistej wartości dla pierwszej predykcji, gdzie różnica wynosi około 0.003. Jednakże w kolejnych wierszach te różnice się zwiększają. 'Ceny_log_pred_4' i 'Ceny_log_pred_5' są mniej oddalone od rzeczywistych cen logarytmicznych. Jedynie w pierwszej prognozie różnice są gorsze niż w kolumnie 'Ceny_log_pred_3'.

Podsumowując, prognozy wyznaczone za pomocą metody Monte Carlo - 'Ceny_log_pred_4', wydają się być najbliższe rzeczywistości. Niemniej jednak, różnice są na tyle małe, że wszystkie trzy poziomy prognoz mają podobną jakość przewidywania.


2. Porównanie cen

```{r}
final_comparison_ceny <- as.data.frame(cbind(
  test$Zamkniecie, 
  predictions_pkt6$Zamkniecie_pred,
  ceny_results$Srednia_Ceny,
  ceny_bootstrap_results$Srednia_Ceny
  ))

colnames(final_comparison_ceny) <- c("Rzeczywiste_ceny","Ceny_pred_3","Ceny_pred_4","Ceny_pred_5")

paged_table(final_comparison_ceny)
```
Model prognozy 'Ceny_pred_4' wydaje się być najbardziej zbliżony w odniesieniu do rzeczywistych cen. Niemniej jedank, przewidywane wartości w dalszym ciągu nie są w pełni zadowalające. 'Ceny_pred_3' są bliskie rzeczywistym wartościom, ale widoczna jest tendencja do zawyżania prognoz. 'Ceny_pred_5' są podobne do prognoz 'Ceny_pred_4'. Są w miarę zbliżone do rzeczywistych wartości. Jedynie druga predykcja odbiega od rzeczywistej wartości o ok. 0.12, natomiast pozostałe oscylują w granicach błędu 0.008-0.04.


Źródła:
https://www.investopedia.com/terms/m/montecarlosimulation.asp