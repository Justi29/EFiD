---
title: "Projekt 2, grupa 5, spółka Betacom"
author: "Karolina Szot, Justyna Wachowiak, Julia Pawluś"
date: "2024-10-11"
output:
  html_document:
    code_folding: hide
  pdf_document: default
---

```{r message=FALSE, warning=FALSE, include=FALSE}
library(rmarkdown)
library(tseries)
library(forecast)
library(lmtest)
library(FinTS)
library(rugarch)
```

## Opis badania
Dane ze stooq, nie bylo naszego numerku spolki, dlatego wzielysmy z ostatnich 20 spolek.

## Dane BETACOM od 1 września 2023 do 4 października 2024

```{r}
dane <- read.csv2("bcm_d.csv", sep = ",", dec = ".", header = T)
paged_table(dane)
```
### Wyznaczenie logarytmicznych cen i stóp zwrotu
```{r}
df <- data.frame(Data = as.Date(dane$Data), Zamkniecie = dane$Zamkniecie, Zamkniecie_log = NA, Stopa_zwrotu_log = NA)
```

```{r}
# Log ceny
for (i in 1:nrow(df)){
  df[i, 3] <- log(df[i,2])
}

# Stopy zwrotu logarytmiczne
for (i in 2:nrow(df)){
  df[i, 4] <- log(df[i, 2]/df[i-1, 2])
}

new_df <- df[-1,]

# Nowe dane
paged_table(new_df)
```

### Podział danych na treningowe i testowe
opis
```{r}
train <- new_df[-((nrow(new_df)-3):nrow(new_df)), ]
test <-  tail(new_df, 4)
```
procentowe/liczbowe przedstawienie


## 1. Test ADF - badanie stacjonarności szeregów
H0: szereg jest niestacjonarny
H1: szereg jest stacjonarny

```{r warning=FALSE}
adf.test(train$Zamkniecie_log) # niestacjonarny
#  p-value = 0.7739 > 0.05

adf.test(train$Stopa_zwrotu_log) # stacjonarny
# p-value = 0.01 < 0.05
```
Z testów wynika, że logarytmiczne ceny są niestacjonarne, ponieważ p-value=0.7739, w związku z czym nie ma podstaw do odrzucenia H0. Natomiast, dla logarytmicznych stóp zwrotu p-value=0.01, zatem odrzucamy hipotezę zerową, czyli szereg jest stacjonarny.

## 2. Wybór modelu ARMA/ARIMA
```{r}
model <- auto.arima(train$Stopa_zwrotu_log)
model
```
Najlepszy model dla logarytmicznych stóp zwrotu  - ARIMA(0,0,1)
Interpretacja ARMA(0,1):

### Badanie autokorelacji składników losowych
#### Wykres ACF
```{r}
# składnik losowy == reszty
reszty <- model$residuals

# autokorelacja
Acf(reszty, main="ACF - Stopy zwrotu log")
```
Opis

#### Test Ljung-Boxa
H0: Brak autokorelacji
H1: Występuje autokorelacja

```{r}
Box.test(reszty, lag = 1, type = "Ljung-Box")$p.value
# 0.8797915 > 0.05 brak autokorelacji
```
Opis


### Badanie istotności parametrów przy najwyższych opóźnieniach
```{r}
coeftest(model)
```
Opis (u nas 1 opoznienie)

### Badanie białego szumu
Aby reszty były białym szumem, muszą spełniać następujące warunki:

1. Wartość oczekiwana równa zero. E(x) = 0
2. Stała wariancja. var(x) = const
3. Brak autokorelacji. corr = 0

W naszym modelu:
Na wcześniej przedstawionym wykresie ACF, jasno widać, że mamy brak autokorelacji w resztach modelu.
```{r}
cat("Średnia reszt: ", mean(reszty), "\n")
```

Test t-studenta:
H0: Średnia reszt jest równa zero.
H1: Średnia reszt jest różna od zera.
```{r}
t.test(reszty, mu = 0) # p-value = 0.9615 -> H0: średnia reszt = 0
```
p-value jest większe niż poziom istotności (0.05), a zatem nie ma podstaw do odrzucenia hipotezy zerowej, co oznacza, że średnia reszt nie różni się istotnie od zera.

Badanie wariancji reszt:
```{r}
reszty_sq <- reszty^2
Box.test(reszty_sq, lag = 1, type = "Ljung-Box") # p-value = 0.1194 -> brak autokorelacji
# Test Arch na heteroskedastyczność
ArchTest(reszty, lags = 1) # p-value = 0.122 -> no ARCH effects
```
Z testu Ljung-Boxa p-value wynosi 0.1194, czyli jest większe niż przyjęty poziom istotności 0.05, stąd też nie ma podstaw do odrzucenia hipotezy zerowej o braku autokorelacji w kwadratach reszt.
W teście ARCH p-value = 0.122, co również wskazuje na brak podstaw do odrzucenia hipotezy zerowej o braku efektów ARCH. Oznacza to, że nie występuje heteroskedastyczność w resztach modelu, czyli wariancja jest stała.

Reszty w tym modelu można uznać za biały szum.


## 3. Prognozy logarytmicznych stóp zwrotu, logarytmów cen i cen aż do 4 notowań.

Wybrany model z pkt.2 - ARMA(0,1).
Wyznaczamy najlepszy model dla logarytmicznych cen:
```{r}
model_2 <- auto.arima(train$Zamkniecie_log)
model_2
```
Wybieramy model ARIMA(0,1,1).

```{r}
stopy_zwr_model <- arima(train$Stopa_zwrotu_log, order=c(0,0,1))
ceny_log_model <- arima(train$Zamkniecie_log, order=c(0,1,1))
```

Zakładamy rozkład normalny dla logarytmicznych stóp zwrotu, czyli logarytmiczne ceny mają warunkowy rozkład normalmny. Zatem ceny mają rozkład logarytmicznie normalny.

#### Predykcje logarytmicznych stóp zwrotu
```{r}
forecast_values <- forecast(stopy_zwr_model, h=4, level=95)
predict <- as.data.frame(forecast_values)
real_values <- tail(test$Stopa_zwrotu_log, 4)

comparison <- data.frame(
  Actual = real_values,
  Forecast = predict$`Point Forecast`,
  Lower95 = predict$`Lo 95`,
  Upper95 = predict$`Hi 95`
)

paged_table(comparison)
```

#### Predykcje logarytmicznych cen
```{r}
forecast_values <- forecast(ceny_log_model, h=4, level=95)
predict_2 <- as.data.frame(forecast_values)
real_values <- tail(test$Zamkniecie_log, 4)

comparison_2 <- data.frame(
  Actual = real_values,
  Forecast = predict_2$`Point Forecast`,
  Lower95 = predict_2$`Lo 95`,
  Upper95 = predict_2$`Hi 95`
)

paged_table(comparison_2)
```

#### Predykcja cen. Zestawienie wszystkich predykcji wraz z przedziałami ufności
```{r}
predictions <- data.frame(
  Zamkniecie_pred = NA,
  Lower_cena = NA,
  Upper_cena = NA,
  Zamkniecie_log_pred = predict_2$`Point Forecast`,
  Lower_log_cena = NA,
  Upper_log_cena = NA,
  Stopa_zwrotu_log_pred = predict$`Point Forecast`,
  Lower_st_zw = predict$`Lo 95`,
  Upper_st_zw = predict$`Hi 95`
)

# Old version
# Ostatnia znana cena log
# cena_log <- train[nrow(train),3]
#
# Predykcja logarytmicznych cen
# for (i in 1:4){
#   stopa_zwrotu <- predictions[i,"Stopa_zwrotu_log_pred"]
#   predictions[i,"Zamkniecie_log_pred"] <- cena_log + stopa_zwrotu
#   cena_log <- predictions[i,"Zamkniecie_log_pred"]
# }


# Predykcja cen
for (i in 1:4){
  mi <- predictions[i,"Zamkniecie_log_pred"]
  
  temp_df <- as.data.frame(c(train$Zamkniecie_log, predictions$Zamkniecie_log[1:i]))
  colnames(temp_df) <- c("Zamkniecie_log_combined")
  
  # Odchylenie standardowe
  sd <- sd(temp_df$Zamkniecie_log_combined)
  
  # Prognozowana cena
  predictions[i,"Zamkniecie_pred"] <- exp(mi+sd/2)
  
  # Obliczanie przedziałów ufności dla logarytmicznych cen
  z_value <- qnorm(0.975)
  predictions[i, "Lower_log_cena"] <- mi - z_value * (sd / sqrt(nrow(temp_df)))
  predictions[i, "Upper_log_cena"] <- mi + z_value * (sd / sqrt(nrow(temp_df)))
  
  
  # Obliczanie przedziałów ufności dla cen
  mi_2 <- predictions[i,"Zamkniecie_pred"]
  temp_df_2 <- as.data.frame(c(train$Zamkniecie, predictions$Zamkniecie_pred[1:i]))
  colnames(temp_df_2) <- c("Zamkniecie_combined")

  sd_2 <- sd(temp_df_2$Zamkniecie_combined)
  
  predictions[i, "Lower_cena"] <- mi_2 - z_value * (sd_2 / sqrt(nrow(temp_df_2)))
  predictions[i, "Upper_cena"] <- mi_2 + z_value * (sd_2 / sqrt(nrow(temp_df_2)))
}

paged_table(predictions)
```

#### Porównanie rzeczywistych wartości z predykcjami
```{r}
result_df <- as.data.frame(cbind(test$Zamkniecie, predictions$Zamkniecie_pred, test$Zamkniecie_log, predictions$Zamkniecie_log, test$Stopa_zwrotu_log, predictions$Stopa_zwrotu_log_pred))

colnames(result_df) <- c("Zamkniecie","Zamkniecie_pred","Zamkniecie_log","Zamkniecie_log_pred","Stopa_zwrotu_log","Stopa_zwrotu_log_pred")

paged_table(result_df)
```


## 4. Monte Carlo
Na podstawie rozkładu reszt modelu dopasowanego w pkt.2. symulacyjnie (za pomocą metody Monte Carlo) wyznaczyć prognozy logarytmów cen i samych cen aż do 4 notowań. Na tej podstawie wyznaczyć także 95% przedziały ufności dla wartości logarytmów cen i samych cen. Uzyskane w ten sposób wyniki porównać z prognozami z punktu 3. 

```{r}
reszty_2 <- residuals(ceny_log_model)
mu <- 0
sigma <- sd(reszty_2)

n_symulacji <- 1000
n_prognoz <- 4

prognozy_log <- matrix(0, nrow = n_symulacji, ncol = n_prognoz)

ostatni_log <- tail(train$Zamkniecie_log, 1)


set.seed(123)
for (j in 1:n_symulacji) {
  prognozy_log[j, 1] <- ostatni_log + rnorm(1, mean = mu, sd = sigma)
  for (i in 2:n_prognoz) {
    prognozy_log[j, i] <- prognozy_log[j, i - 1] + rnorm(1, mean = mu, sd = sigma)
  }
}

prognozy_ceny <- exp(prognozy_log + (sigma^2 / 2))

log_forecast_mean <- apply(prognozy_log, 2, mean)
log_ci_lower <- apply(prognozy_log, 2, function(x) quantile(x, probs = 0.025))
log_ci_upper <- apply(prognozy_log, 2, function(x) quantile(x, probs = 0.975))

cena_forecast_mean <- apply(prognozy_ceny, 2, mean)
cena_ci_lower <- apply(prognozy_ceny, 2, function(x) quantile(x, probs = 0.025))
cena_ci_upper <- apply(prognozy_ceny, 2, function(x) quantile(x, probs = 0.975))

log_ceny_results <- data.frame(
  Horyzont_Prognozy = 1:n_prognoz,
  Srednia_Log_Ceny = log_forecast_mean,
  Dolny_Przedzial95_Log = log_ci_lower,
  Gorny_Przedzial95_Log = log_ci_upper
)

ceny_results <- data.frame(
  Horyzont_Prognozy = 1:n_prognoz,
  Srednia_Ceny = cena_forecast_mean,
  Dolny_Przedzial95_Cena = cena_ci_lower,
  Gorny_Przedzial95_Cena = cena_ci_upper
)
```

#### Prognozy logarytmów cen
```{r}
paged_table(log_ceny_results)
```

#### Prognozy cen
```{r}
paged_table(ceny_results)
```

Opis - porównanie z 3

## 5. Metody bootstrapowe
Na podstawie oszacowanych reszt, za pomocą metod bootstrapowych wyznaczyć prognozy logarytmów cen i samych cen aż do 4 sesji. Wyznaczyć także 95% przedziały ufności dla wartości logarytmów cen i samych cen. Uzyskane w ten sposób wyniki porównać z prognozami z punktu 3 i 4.

```{r}
set.seed(123)

n_bootstrap <- 1000
n_prognoz <- 4
reszty_2 <- residuals(ceny_log_model)

prognozy_log_bootstrap <- matrix(0, nrow = n_bootstrap, ncol = n_prognoz)

ostatni_log <- tail(train$Zamkniecie_log, 1)


for (j in 1:n_bootstrap) {
  prognozy_log_bootstrap[j, 1] <- ostatni_log + sample(reszty_2, 1, replace = TRUE)
  for (i in 2:n_prognoz) {
    prognozy_log_bootstrap[j, i] <- prognozy_log_bootstrap[j, i - 1] + sample(reszty_2, 1, replace = TRUE)
  }
}

sigma <- sd(reszty_2)
prognozy_ceny_bootstrap <- exp(prognozy_log_bootstrap  + (sigma^2 / 2))

log_forecast_mean_bootstrap <- apply(prognozy_log_bootstrap, 2, mean)
log_ci_lower_bootstrap <- apply(prognozy_log_bootstrap, 2, function(x) quantile(x, probs = 0.025))
log_ci_upper_bootstrap <- apply(prognozy_log_bootstrap, 2, function(x) quantile(x, probs = 0.975))

cena_forecast_mean_bootstrap <- apply(prognozy_ceny_bootstrap, 2, mean)
cena_ci_lower_bootstrap <- apply(prognozy_ceny_bootstrap, 2, function(x) quantile(x, probs = 0.025))
cena_ci_upper_bootstrap <- apply(prognozy_ceny_bootstrap, 2, function(x) quantile(x, probs = 0.975))

log_ceny_bootstrap_results <- data.frame(
  Horyzont_Prognozy = 1:n_prognoz,
  Srednia_Log_Ceny = log_forecast_mean_bootstrap,
  Dolny_Przedzial95_Log = log_ci_lower_bootstrap,
  Gorny_Przedzial95_Log = log_ci_upper_bootstrap
)

ceny_bootstrap_results <- data.frame(
  Horyzont_Prognozy = 1:n_prognoz,
  Srednia_Ceny = cena_forecast_mean_bootstrap,
  Dolny_Przedzial95_Cena = cena_ci_lower_bootstrap,
  Gorny_Przedzial95_Cena = cena_ci_upper_bootstrap
)
```

#### Prognozy logarytmów cen
```{r}
paged_table(log_ceny_bootstrap_results)
```

#### Prognozy cen
```{r}
paged_table(ceny_bootstrap_results)
```

## 6. Model ARMA-GARCH
Badanie z punktów 3-5 powtórzyć przy założeniu występowania efektu ARCH, tzn. dla odpowiedniego modelu ARMA-GARCH. Przeprowadzić też test występowania efektu ARCH.

#### Test ARCH
Reszty z modelu logarytmicznych stóp zwrotu
```{r}
reszty_st_zw <- residuals(stopy_zwr_model)
ArchTest(reszty_st_zw, lags = 1)
```
Reszty z modelu logarytmicznych cen
```{r}
reszty_log <- residuals(ceny_log_model)
ArchTest(reszty_log, lags = 1)
```
W obu przypadkach p-value są większe przyjęty poziom istotności 0.05, dlatego odrzucamy H0, a to oznacza, że występują efekty ARCH.

#### Badanie z pkt. 3
```{r}
# Dla arima(0,0,1), garch(1,1)
spec <- ugarchspec(
  variance.model = list(model = "sGARCH", garchOrder = c(1, 1)),
  mean.model = list(armaOrder = c(0, 1), include.mean = TRUE),
  distribution.model = "norm"
)

fit <- ugarchfit(spec = spec, data = train$Stopa_zwrotu_log)
```

```{r}
# dla arima(0,1,1), garch(1,1)
spec2 <- ugarchspec(
  variance.model = list(model = "sGARCH", garchOrder = c(1, 1)),
  mean.model = list(armaOrder = c(0, 1), include.mean = TRUE, arfima = TRUE),
  distribution.model = "norm"
)

fit2 <- ugarchfit(spec = spec2, data = train$Zamkniecie_log)
```

```{r}
# Prognoza logarytmicznych stóp zwrotu
prognoza_stop_zwr <- ugarchforecast(fit, n.ahead = 4)
prognozy_stop_zwr <- as.data.frame(fitted(prognoza_stop_zwr))
colnames(prognozy_stop_zwr) <- c("Prognoza_Stopy_Zwrotu")

# Prognoza logarytmicznych cen
prognoza_log_cena <- ugarchforecast(fit2, n.ahead = 4)
prognoza_log_cena <- as.data.frame(fitted(prognoza_log_cena))
colnames(prognoza_log_cena) <- c("Prognoza_Log_Cena")

predictions_pkt6 <- data.frame(
  Zamkniecie_pred = NA,
  Lower_cena = NA,
  Upper_cena = NA,
  Zamkniecie_log_pred = prognoza_log_cena$Prognoza_Log_Cena,
  Lower_log_cena = NA,
  Upper_log_cena = NA,
  Stopa_zwrotu_log_pred = prognozy_stop_zwr$Prognoza_Stopy_Zwrotu,
  Lower_st_zw = NA,
  Upper_st_zw = NA
)

for (i in 1:4){
  mi <- predictions_pkt6[i,"Zamkniecie_log_pred"]
  
  temp_df <- as.data.frame(c(train$Zamkniecie_log, predictions_pkt6$Zamkniecie_log[1:i]))
  colnames(temp_df) <- c("Zamkniecie_log_combined")
  
  # Odchylenie standardowe
  sd <- sd(temp_df$Zamkniecie_log_combined)
  
  # Prognozowana cena
  predictions_pkt6[i,"Zamkniecie_pred"] <- exp(mi+sd/2)
  
  # Obliczanie przedziałów ufności dla logarytmicznych cen
  z_value <- qnorm(0.975)
  predictions_pkt6[i, "Lower_log_cena"] <- mi - z_value * (sd / sqrt(nrow(temp_df)))
  predictions_pkt6[i, "Upper_log_cena"] <- mi + z_value * (sd / sqrt(nrow(temp_df)))
  
  
  # Obliczanie przedziałów ufności dla cen
  mi_2 <- predictions_pkt6[i,"Zamkniecie_pred"]
  temp_df_2 <- as.data.frame(c(train$Zamkniecie, predictions_pkt6$Zamkniecie_pred[1:i]))
  colnames(temp_df_2) <- c("Zamkniecie_combined")

  sd_2 <- sd(temp_df_2$Zamkniecie_combined)
  
  predictions_pkt6[i, "Lower_cena"] <- mi_2 - z_value * (sd_2 / sqrt(nrow(temp_df_2)))
  predictions_pkt6[i, "Upper_cena"] <- mi_2 + z_value * (sd_2 / sqrt(nrow(temp_df_2)))
  
  
  # Obliczanie przedziałów ufności dla logarytmicznych stóp zwrotu
  mi_3 <- predictions_pkt6[i,"Stopa_zwrotu_log_pred"]
  temp_df_3 <- as.data.frame(c(train$Stopa_zwrotu_log, predictions_pkt6$Stopa_zwrotu_log_pred[1:i]))
  colnames(temp_df_3) <- c("Stopa_zwrotu_combined")

  sd_3 <- sd(temp_df_3$Stopa_zwrotu_combined)
  
  predictions_pkt6[i, "Lower_st_zw"] <- mi_3 - z_value * (sd_3 / sqrt(nrow(temp_df_3)))
  predictions_pkt6[i, "Upper_st_zw"] <- mi_3 + z_value * (sd_3 / sqrt(nrow(temp_df_3)))
}

paged_table(predictions_pkt6)
```

```{r}
# Porównanie rzeczywistych wartości z predykcjami
result_df_pkt6 <- as.data.frame(cbind(test$Zamkniecie, predictions_pkt6$Zamkniecie_pred, test$Zamkniecie_log, predictions_pkt6$Zamkniecie_log_pred, test$Stopa_zwrotu_log, predictions_pkt6$Stopa_zwrotu_log_pred))

colnames(result_df_pkt6) <- c("Zamkniecie","Zamkniecie_pred","Zamkniecie_log","Zamkniecie_log_pred","Stopa_zwrotu_log","Stopa_zwrotu_log_pred")

paged_table(result_df_pkt6)
```


#### Badanie z pkt. 4 - Monte Carlo
```{r}
reszty_fit2 <- residuals(fit2)
mu <- 0
sigma <- sd(reszty_fit2)

n_symulacji <- 1000
n_prognoz <- 4

prognozy_log <- matrix(0, nrow = n_symulacji, ncol = n_prognoz)

ostatni_log <- tail(train$Zamkniecie_log, 1)


set.seed(123)
for (j in 1:n_symulacji) {
  prognozy_log[j, 1] <- ostatni_log + rnorm(1, mean = mu, sd = sigma)
  for (i in 2:n_prognoz) {
    prognozy_log[j, i] <- prognozy_log[j, i - 1] + rnorm(1, mean = mu, sd = sigma)
  }
}

prognozy_ceny <- exp(prognozy_log + (sigma^2 / 2))

log_forecast_mean <- apply(prognozy_log, 2, mean)
log_ci_lower <- apply(prognozy_log, 2, function(x) quantile(x, probs = 0.025))
log_ci_upper <- apply(prognozy_log, 2, function(x) quantile(x, probs = 0.975))

cena_forecast_mean <- apply(prognozy_ceny, 2, mean)
cena_ci_lower <- apply(prognozy_ceny, 2, function(x) quantile(x, probs = 0.025))
cena_ci_upper <- apply(prognozy_ceny, 2, function(x) quantile(x, probs = 0.975))

log_ceny_results <- data.frame(
  Horyzont_Prognozy = 1:n_prognoz,
  Srednia_Log_Ceny = log_forecast_mean,
  Dolny_Przedzial95_Log = log_ci_lower,
  Gorny_Przedzial95_Log = log_ci_upper
)

ceny_results <- data.frame(
  Horyzont_Prognozy = 1:n_prognoz,
  Srednia_Ceny = cena_forecast_mean,
  Dolny_Przedzial95_Cena = cena_ci_lower,
  Gorny_Przedzial95_Cena = cena_ci_upper
)
```

#### Prognozy logarytmów cen
```{r}
paged_table(log_ceny_results)
```

#### Prognozy cen
```{r}
paged_table(ceny_results)
```


#### Badanie z pkt. 5 - metody bootstrapowe
```{r}
set.seed(123)

reszty_fit2 <- residuals(fit2)

prognozy_log_bootstrap <- matrix(0, nrow = n_bootstrap, ncol = n_prognoz)

ostatni_log <- tail(train$Zamkniecie_log, 1)


for (j in 1:n_bootstrap) {
  prognozy_log_bootstrap[j, 1] <- ostatni_log + sample(reszty_fit2, 1, replace = TRUE)
  for (i in 2:n_prognoz) {
    prognozy_log_bootstrap[j, i] <- prognozy_log_bootstrap[j, i - 1] + sample(reszty_fit2, 1, replace = TRUE)
  }
}

prognozy_ceny_bootstrap <- exp(prognozy_log_bootstrap)

log_forecast_mean_bootstrap <- apply(prognozy_log_bootstrap, 2, mean)
log_ci_lower_bootstrap <- apply(prognozy_log_bootstrap, 2, function(x) quantile(x, probs = 0.025))
log_ci_upper_bootstrap <- apply(prognozy_log_bootstrap, 2, function(x) quantile(x, probs = 0.975))

cena_forecast_mean_bootstrap <- apply(prognozy_ceny_bootstrap, 2, mean)
cena_ci_lower_bootstrap <- apply(prognozy_ceny_bootstrap, 2, function(x) quantile(x, probs = 0.025))
cena_ci_upper_bootstrap <- apply(prognozy_ceny_bootstrap, 2, function(x) quantile(x, probs = 0.975))

log_ceny_bootstrap_results <- data.frame(
  Horyzont_Prognozy = 1:n_prognoz,
  Srednia_Log_Ceny = log_forecast_mean_bootstrap,
  Dolny_Przedzial95_Log = log_ci_lower_bootstrap,
  Gorny_Przedzial95_Log = log_ci_upper_bootstrap
)

ceny_bootstrap_results <- data.frame(
  Horyzont_Prognozy = 1:n_prognoz,
  Srednia_Ceny = cena_forecast_mean_bootstrap,
  Dolny_Przedzial95_Cena = cena_ci_lower_bootstrap,
  Gorny_Przedzial95_Cena = cena_ci_upper_bootstrap
)
```

#### Prognozy logarytmów cen
```{r}
paged_table(log_ceny_bootstrap_results)
```

#### Prognozy cen
```{r}
paged_table(ceny_bootstrap_results)
```



Źródła:
https://www.investopedia.com/terms/m/montecarlosimulation.asp